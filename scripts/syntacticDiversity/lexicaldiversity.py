# -*- coding: utf-8 -*-
"""LexicaLDiversity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GvZ7AG5FegEfXD4OgkKw73SHesjZ0lHi

Notebook on Experiments with Dimitar and Matt
"""
import codecs
import statistics
import spacy_udpipe

nlpEn = spacy_udpipe.load("en")
#nlpFr = spacy_udpipe.load("fr")
#nlpEs = spacy_udpipe.load("es")

nlpEn.max_length = 300000000
#nlpFr.max_length = 300000000
#nlpEs.max_length = 300000000

"""#### EXAMPLE DATA ####

**bold text**
Por primera vez , en esta conferencia los países africanos y Europa se reunirán para desarrollar un plan de acción común .
Mi opinión , como ponente , es que esto está en contra de la lógica general de toda la regulación .
Es evidente que , con tales resoluciones , la verdadera ansiedad existencial y la necesidad de los agricultores europeos no pueden abordarse , dado que hay 80 tipos diferentes de virus y 300 millones de animales en Europa .
Por todas estas razones , esperamos que el estudio que la Comisión se lleve a cabo junto con expertos de los Estados miembros y otros países que pudieran ayudarnos a ser de gran asistencia ni a formular una nueva estrategia o que confirme el uno que hemos sido siguiendo .
Además , la Comisión pretende celebrar una reunión con el sector del atún para finales de 2005 , para debatir todas las cuestiones pertinentes .
Algunos de ustedes han señalado las contradicciones que existen en Corea del Norte .
¿ Ha tomado el Consejo , o hace el plan de adoptar , cualquier medidas a escala de la Unión para llevar a cabo una prohibición de la fabricación , exportación , importación o transferencia de minas antipersonas ? Pregunta 9 por el Sr. John Iversen ( H-04@@ 33 / 97 ) :
El motivo es evidente .
No es posible dimitir del KGB ninguna más de lo que se encuentra de la Asociación ha sido de la cabeza .
Señor Presidente , tan solo unos instantes después de sesión , intervengo de nuevo , este momento en mi calidad de ponente de opinión de la Comisión de Asuntos Económicos y Monetarios y de Política Industrial .

#### CREATE NESTED DICTIONARY ####
"""


"""### DIVERSITY MEASURE ###

Simpson Diversity, Inverse Simpson Diversity and Shannon Diversity => measures of diversity (abundance and evenness) used mainly in biology although Shannon Diversity has its origin in Communication Theory.
"""

def simpson_diversity(wordFormDict):

    """
    Given a dictionary { 'wordform': count } , returns the Simpson Diversity Index
    
    >>> simpson_di({'intelligente': 10, 'intelligent': 12})
    """

    def p(n, N):
        """ Relative abundance """
        if n ==  0:
            return 0
        else:
            return float(n)/N

    N = sum(wordFormDict.values())
    return sum(p(n, N)**2 for n in wordFormDict.values() if n != 0)

def inverse_simpson_diversity(wordFormDict):
    """ 
    Same as previous but inverse as simpson diversity metrics is a bit counterintuitive with 1 being not diverse at all and 0 being the most diverse
    """
    return float(1)/simpson_diversity(wordFormDict)

"""# Shannon Diversity #
The Shannon-Weiner diversity represent the proportion of species abundance in the population. Its being at maximum when all species occur in similar number of individuals and the lowest when the sample contain one species. From my experience there is no limit to compare the diversity value with as for evenness, which resricted between 0-1. For Example, if the sample contain 4 species each represented by 5o individuals the, diversity H equal 1.3863, and if the sample contain 5 species (one more) and each represented by similar number of individuals (50), the diversity equal 1.6094.
"""

def shannon_diversity(wordFormDict):
    """ Given a hash { 'species': count } , returns the SDI
    
    >>> sdi({'a': 10, 'b': 20, 'c': 30,})
    1.0114042647073518"""
    
    from math import log as ln
    
    def p(n, N):
        """ Relative abundance """
        if n ==  0:
            return 0
        else:
            return (float(n)/N) * ln(float(n)/N)
            
    N = sum(wordFormDict.values())
    
    return -sum(p(n, N) for n in wordFormDict.values() if n != 0)

def compute_simpDiv(nestedDict):
  """ function that takes nested dictionary of as input and returns a dictionary with the simpson diversity for every lemma
  example input : {lemma1:{wordf1: count1, wordf2: count2}, lemma2 {wordform1: count1}}
  output {lemma1: simpDiv1, lemma2:simpDiv2}
  """
  simpsonDict={}
  for l in nestedDict:
      simpsonDict[l]=simpson_diversity(nestedDict[l])
  return simpsonDict

def compute_invSimpDiv(nestedDict):
  """ function that takes nested dictionary of as input and returns a dictionary with the simpson diversity for every lemma
  example input : {lemma1:{wordf1: count1, wordf2: count2}, lemma2 {wordform1: count1}}
  output {lemma1: simpDiv1, lemma2:simpDiv2}
  """
  simpsonDict={}
  for l in nestedDict:
    simpsonDict[l]=inverse_simpson_diversity(nestedDict[l])
  return simpsonDict

def compute_shannonDiv(nestedDict):
  """ function that takes nested dictionary of as input and returns a dictionary with the shannon diversity for every lemma
  example input : {lemma1:{wordf1: count1, wordf2: count2}, lemma2 {wordform1: count1}}
  output {lemma1: simpDiv1, lemma2:simpDiv2}
  """
  shannonDict={}
  for lem in nestedDict:
    shannonDict[lem]=shannon_diversity(nestedDict[lem])
  return shannonDict
"""### A test dictionary ###"""

def computeAverageValue(dataD):
  return statistics.mean(dataD.values())

def main():
  filename="../data/train-es-en-TRANS-BPE.out"
  with codecs.open(filename, "r", "utf-8") as fn:
      text=fn.readlines()

  textSample=text[0:5]
  textStr=" ".join(textSample)
  docEn=nlpEn(textStr)
  lemmaWordD={}


  for token in docEn:
      lemma=token.lemma_
      tokenLow=str(token).lower()
      # existing lemma
      if lemma in lemmaWordD:
          if tokenLow in lemmaWordD[lemma]: 
              lemmaWordD[lemma][tokenLow]+=1
          # unexisting wordform
          else:
              lemmaWordD[lemma][tokenLow]=1
  
      # unexisting lemma
      else:
          lemmaWordD[lemma]={}
          # existing token
          if token in lemmaWordD[lemma]:
              lemmaWordD[lemma][tokenLow]+=1
          #unexisting token
          else:
              lemmaWordD[lemma][tokenLow]=1


  simpDivD=compute_simpDiv(lemmaWordD)
  invSimpDiv=compute_invSimpDiv(lemmaWordD)
  shannonDiv=compute_shannonDiv(lemmaWordD)
  
  print(str(computeAverageValue(simpDivD)))
  print(str(computeAverageValue(invSimpDiv)))
  print(str(computeAverageValue(shannonDiv)))

if __name__=="__main__":
  main()
